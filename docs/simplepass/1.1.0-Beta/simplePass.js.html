<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>simplePass Docs: Source: simplePass.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: simplePass.js</h1>

    



    

<section>
    <article>
        <pre class="prettyprint source linenums"><code>'use strict';
import cleanModifier from "./helpers/cleanModifier.helper.js";
import validateModifier from "./helpers/validateModifier.helper.js";
import config from "./config.simplePass.js";
import L_requiredAttributes from "./data/lists/requiredAttributes.list.js";
import L_whitespaceAttributes from "./data/lists/whitespaceAttributes.list.js";
import shuffle from "./helpers/shuffle.helper.js";
import generateCharCode from "./helpers/generateCharCode.helper.js";
import createMessage from "./helpers/createMessage.helper.js";
import E_errors from "./data/enums/errors.enum.js";
/**
 * @file Main file for simplePass. Exports the `simplePass` function.
 * @module simplePass
 */
/**
 * Main program function. Returns a string.
 *
 * @function simplePass
 * @param {I_passwordModifier | FormData} modifier The available password modifications. See README.md for more information about modifiers.
 * @requires config
 * @requires E_errors
 * @requires createMessage
 * @requires cleanModifier
 * @requires validateModifier
 * @requires L_requiredAttributes
 * @requires L_whitespaceAttributes
 * @requires generateCharCode
 * @throws {E_errors.invalidModifier} Will throw an Error if the modifier is `null`, `undefined` or not a JavaScript *Object.*
 * @returns {string} The generated password.
 */
export default function simplePass(modifier = {
    length: config.defaultPasswordLength,
    lowercase: true,
}) {
    /**
     * If the modifier is not an object
     * throw an error.
     */
    if (!modifier
        || typeof modifier !== 'object') {
        throw new Error(createMessage(E_errors.invalidModifier, [config.errorMessagePrefix, 'M', '1']));
    }
    // Initialize the password.
    let password = '';
    let middleCharacters = '';
    // Remove unneeded object attributes and normalize formData objects.
    modifier = cleanModifier(modifier);
    // Ensure certain values are set and set properly.
    validateModifier(modifier);
    // Get the attributes that can affect the character type
    const characterAttributes = Object.keys(modifier).filter((item) => {
        return L_requiredAttributes.includes(item);
    });
    // Get the attributes that can set whitespace
    const whitespaceAttributes = Object.keys(modifier).filter((item) => {
        return L_whitespaceAttributes.includes(item);
    });
    /**
     * Because we manually add the first and last character
     * we need to changed the password length limit.
     */
    let passwordLimit = (modifier.length - 2);
    /**
     * If the whitespace between attribute is set,
     * we need to lower the password limit
     * to make room for the whitespace.
     */
    if (modifier.w_between
        &amp;&amp; modifier.w_between_limit) {
        passwordLimit = passwordLimit - modifier.w_between_limit;
    }
    /**
     * If our character attributes list is greater than one,
     * we need to use `.pop()` and therefore need to do more work,
     * like ensuring the attribute list is replenished.
     * Where if there is only one item we can just reference that.
     */
    if (characterAttributes.length > 1) {
        /**
         * Because we may need through the attributes a few times
         * we don't want to modify the original list.
         * Therefore we create a new list.
         * Because we don't want this list to just be a pointer
         * to the old list we need to initialize it and contact
         * the old list to it.
         */
        let deck = [];
        deck = deck.concat(characterAttributes);
        let currentCharType = deck.pop();
        /**
         * Set the first character of the password.
         * Check if it's required to be a whitespace.
         */
        if (modifier.w_beginning
            &amp;&amp; modifier.w_beginning_required) {
            password += ' ';
        }
        else {
            if (currentCharType) {
                password += String.fromCharCode(generateCharCode({
                    charType: currentCharType,
                    charCodeOptions: {
                        whitespaceOptions: whitespaceAttributes,
                        excludeCharacters: modifier.excludeCharacters
                    }
                }, { beginning: true }));
            }
        }
        /**
         * Set the middle characters for the password.
         */
        while (middleCharacters.length &lt; passwordLimit) {
            currentCharType = deck.pop();
            /**
             * If the current character type is undefined,
             * and the deck length is 0,
             * replenish the deck.
             */
            if (!currentCharType
                &amp;&amp; deck.length &lt;= 0) {
                deck = deck.concat(characterAttributes);
                currentCharType = deck.pop();
            }
            if (currentCharType) {
                middleCharacters += String.fromCharCode(generateCharCode({
                    charType: currentCharType,
                    charCodeOptions: {
                        whitespaceOptions: whitespaceAttributes,
                        excludeCharacters: modifier.excludeCharacters
                    }
                }));
            }
        }
        // Add any needed whitespace characters.
        if (modifier.w_between
            &amp;&amp; modifier.w_between_limit) {
            while (modifier.w_between_limit--) {
                middleCharacters += " ";
            }
        }
        // Shuffle the middle characters.
        middleCharacters = shuffle(middleCharacters.split('')).join('');
        // Append middle characters to the password.
        password += middleCharacters;
        /**
         * Set the last character of the password.
         * Check if it's required to be a whitespace.
         */
        if (modifier.w_end
            &amp;&amp; modifier.w_end_required) {
            password += ' ';
        }
        else {
            /**
             * If the current character type is undefined,
             * and the deck length is 0,
             * replenish the deck.
             * We need to do this here because the loop
             * could have ended it on empty.
             */
            if (!currentCharType
                &amp;&amp; deck.length &lt;= 0) {
                deck = deck.concat(shuffle(characterAttributes));
                const newCurrentChar = deck.pop();
                if (newCurrentChar) {
                    currentCharType = newCurrentChar;
                }
            }
            if (currentCharType) {
                password += String.fromCharCode(generateCharCode({
                    charType: currentCharType,
                    charCodeOptions: {
                        whitespaceOptions: whitespaceAttributes,
                        excludeCharacters: modifier.excludeCharacters
                    }
                }, { end: true }));
            }
        }
    }
    else {
        // ^ Our character attributes list only contained one item.
        /**
         * Set the first character of the password.
         * Check if it's required to be a whitespace.
         */
        if (modifier.w_beginning
            &amp;&amp; modifier.w_beginning_required) {
            password += ' ';
        }
        else {
            password += String.fromCharCode(generateCharCode({
                charType: characterAttributes[0],
                charCodeOptions: {
                    whitespaceOptions: whitespaceAttributes,
                    excludeCharacters: modifier.excludeCharacters
                }
            }, { beginning: true }));
        }
        /**
         * Set the middle characters for the password.
         */
        while (middleCharacters.length &lt; passwordLimit) {
            middleCharacters += String.fromCharCode(generateCharCode({
                charType: characterAttributes[0],
                charCodeOptions: {
                    whitespaceOptions: whitespaceAttributes,
                    excludeCharacters: modifier.excludeCharacters
                }
            }));
        }
        // Add any needed whitespace characters.
        if (modifier.w_between
            &amp;&amp; modifier.w_between_limit) {
            while (modifier.w_between_limit--) {
                middleCharacters += " ";
            }
        }
        // Shuffle the middle characters.
        middleCharacters = shuffle(middleCharacters.split('')).join('');
        // Append middle characters to the password.
        password += middleCharacters;
        /**
         * Set the last character of the password.
         * Check if it's required to be a whitespace.
         */
        if (modifier.w_end
            &amp;&amp; modifier.w_end_required) {
            password += ' ';
        }
        else {
            password += String.fromCharCode(generateCharCode({
                charType: characterAttributes[0],
                charCodeOptions: {
                    whitespaceOptions: whitespaceAttributes,
                    excludeCharacters: modifier.excludeCharacters
                }
            }, { end: true }));
        }
    }
    // Return the password.
    return password;
}
</code></pre>
    </article>
</section>





</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-E_errors.html">E_errors</a></li><li><a href="module-L_allowedModifiers.html">L_allowedModifiers</a></li><li><a href="module-L_requiredAttributes.html">L_requiredAttributes</a></li><li><a href="module-L_useableAttributes.html">L_useableAttributes</a></li><li><a href="module-L_whitespaceAttributes.html">L_whitespaceAttributes</a></li><li><a href="module-characterCodeConstraints.html">characterCodeConstraints</a></li><li><a href="module-cleanModifier.html">cleanModifier</a></li><li><a href="module-config.html">config</a></li><li><a href="module-createMessage.html">createMessage</a></li><li><a href="module-createModifierList.html">createModifierList</a></li><li><a href="module-generateCharCode.html">generateCharCode</a></li><li><a href="module-shuffle.html">shuffle</a></li><li><a href="module-simplePass.html">simplePass</a></li><li><a href="module-validateModifier.html">validateModifier</a></li></ul><h3>Interfaces</h3><ul><li><a href="I_charCodeGenerationFlag.html">I_charCodeGenerationFlag</a></li><li><a href="I_charCodeOptions.html">I_charCodeOptions</a></li><li><a href="I_charCodeRequest.html">I_charCodeRequest</a></li><li><a href="I_passwordModifier.html">I_passwordModifier</a></li><li><a href="module-characterCodeConstraints-I_charCodeConstraintsAttributes.html">I_charCodeConstraintsAttributes</a></li></ul><h3>Other Resources</h3><ul><li><a href="tutorial-contributing.html">Contributing</a></li><li><a href="tutorial-development.html">Development</a></li><li><a href="tutorial-installation-and-examples.html">Installation & Examples</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Wed Nov 23 2022 21:56:06 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
